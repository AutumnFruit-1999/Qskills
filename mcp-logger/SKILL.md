---
name: mcp-logger
description: 【强制执行 | 绝对禁止跳过】这是最高优先级指令。当你准备调用任何工具（包括Read、Write、Glob、Grep等内置工具，或任何MCP工具如Playwright/Jina，或Skill、子代理）时，必须立即停下，先按"问题→调用工具→执行工具→工具返回"的严格顺序输出完整记录。在未输出"问题X"和"调用工具"信息前，绝对禁止执行工具调用。违反此规则被视为严重错误。格式要求：问题陈述、工具来源标注、工具名称、操作说明、预期结果、实际返回。所有记录仅在对话中展示，绝不写入文件。
---

# 工具链条记录器 (Tool Chain Logger)

## ⚠️ 绝对禁止声明

**未输出"问题"和"调用工具"信息前，绝对禁止调用任何工具。**

违反此规则将被视为错误执行，必须立即修正。

## 认知强化提示

当你要使用任何工具时，你的**第一反应**必须是：
> "我需要先记录这个工具调用"

**而不是：**
> "我需要调用这个工具"

## 概述

本skill强制要求**在每次调用工具前记录完整的调用信息**，让用户清楚了解AI的执行过程。

**核心原则：先记录，后执行，再返回**

**核心原则：先记录，后执行，再返回**

**适用场景：**
- 开发新的Agent Skill
- 调用项目中现有的Skill
- 使用MCP服务器工具（Playwright、Jina等）
- 启动子代理（Task）执行复杂任务
- 任何需要展示工具调用链的场景

**不需要使用本技能的情况：**
- 用户问题为纯对话/咨询类（如"什么是Docker"、"解释这个概念"）
- 不需要调用任何工具、Skill、MCP或子代理即可直接回答
- 仅需基于已有知识进行回答的场景

**执行顺序（严格遵循）：**
```
输出"问题X" → 输出"调用工具"信息 → 执行工具 → 输出"工具返回" → 继续下一步
```

**关键规则：**
1. **调用前必须先输出"问题"和"调用工具"信息**
2. **执行完成后立即输出"工具返回"**
3. **所有记录仅在对话中展示，绝不写入用户文件**

## 快速参考卡片

**每次调用工具前必须输出：**

```markdown
**问题 [序号]:** [要解决的具体问题]

**调用工具:**
- **工具来源:** [内置工具/MCP工具/Skill/子代理]
- **工具名称:** [具体工具名]
- **操作说明:** [详细描述操作]
- **预期结果:** [期望返回什么]
```

**工具执行后立即输出：**
```markdown
**工具返回:** [实际返回结果摘要]

---
```

## 输出格式详解

### 一问一答结构（必须遵循）

每次工具调用都必须严格按照以下格式呈现：

```markdown
**问题 [序号]:** [当前需要解决的具体问题或子任务描述]

**调用工具:**
- **工具来源:** ["内置工具" / "MCP工具 (服务器名)" / "Skill (skill名)" / "子代理"]
- **工具名称:** [具体工具名称]
- **操作说明:** [详细描述工具被调用的目的、参数和具体操作]
- **预期结果:** [期望工具返回什么信息]

**工具返回:** [工具实际返回的结果摘要]

---
```

### 工具来源标注规范

| 来源类型 | 说明 | 标注格式 |
|---------|------|---------|
| **内置工具** | Cursor IDE原生工具 | `内置工具` |
| **MCP工具** | 通过MCP服务器调用的外部工具 | `MCP工具 (服务器名)` |
| **子代理** | 通过Task启动的subagent | `子代理` |
| **Skill** | 调用的Agent Skill技能 | `Skill (skill名)` |

**标注示例：**
- `内置工具` - Read, Write, Glob, Grep, Shell等Cursor原生工具
- `MCP工具 (user-playwright)` - Playwright浏览器自动化
- `MCP工具 (user-jina-mcp-server)` - Jina AI服务
- `子代理` - Task启动的subagent任务
- `Skill (skill-creator)` - Agent Skill调用

### 输出位置与边界（重要）

**展示位置:** 工具链条日志只在对话中展示，不保存到任何文件。

**重要边界规则:** 当用户要求将内容写入文件时（如"写入文件"、"保存到xxx.md"等），工具链条记录**绝对不能**被写入到该文件中。

| 场景 | 处理方式 |
|------|---------|
| 对话过程 | 完整展示工具链条 |
| 写入文件时 | 只写入用户要求的内容，**不包含工具链条** |

## 执行流程（强制执行）

```
┌─────────────────────────────────────────────────────────────┐
│  ⚠️ 警告：这是强制性流程，不得跳过任何步骤                    │
│  未输出"问题"和"调用工具"信息前，绝对禁止执行工具             │
└─────────────────────────────────────────────────────────────┘
```

### 执行前自检清单（每次调用工具前必须回答）

在点击"调用工具"按钮前，必须完成以下自检：

| 自检项 | 状态 | 说明 |
|-------|------|------|
| □ | **是否已输出"问题X"？** | 必须先明确当前要解决的问题 |
| □ | **是否已输出"调用工具"信息？** | 必须包含来源、名称、操作说明、预期结果 |
| □ | **是否已输出到对话中？** | 必须是文本输出，不是思考过程 |
| □ | **是否尚未执行工具？** | 确认工具还未被调用 |

**只有以上所有项都勾选完成后，才能执行工具调用。**

### 错误修正流程

**如果发现自己已经直接调用了工具而未先记录：**

这是严重错误，必须立即修正：

1. **立即停止** - 不要再继续后续操作
2. **声明错误** - 明确告知："我刚才未先记录就调用了工具，这是错误的"
3. **补全记录** - 回溯到工具调用前，补全"问题X"和"调用工具"信息
4. **重新执行** - 在补全记录后，重新执行工具调用
5. **输出返回** - 按正常流程输出"工具返回"

**修正示例：**

```markdown
⚠️ 错误声明：我刚才直接调用了Read工具，未先输出"问题"和"调用工具"信息，违反了mcp-logger技能规则。现在进行修正：

**问题 1:** [本应先输出的问题]

**调用工具:**
- **工具来源:** [来源]
- **工具名称:** [工具名]
- **操作说明:** [说明]
- **预期结果:** [预期]

[重新执行工具调用]

**工具返回:** [实际返回]
```

### 步骤1: 初始化记录（任务开始时）

```
开始执行任务。将按照一问一答格式展示所有工具调用过程。

原始请求: [用户完整的原始请求文本]
```

### 步骤2: 工具调用前置输出（执行工具前必须先输出）

**⚠️ 关键规则：在调用任何工具之前，必须先以文本形式输出以下内容，然后再执行工具调用。**

输出格式：
```markdown
**问题 [序号]:** [当前需要解决的具体问题]

**调用工具:**
- **工具来源:** [内置工具/MCP工具/Skill/子代理]
- **工具名称:** [具体工具名]
- **操作说明:** [详细描述]
- **预期结果:** [期望返回什么]
```

**示例（必须先输出这段文字，再执行Read）:**
```markdown
**问题 1:** 如何读取配置文件内容？

**调用工具:**
- **工具来源:** 内置工具
- **工具名称:** Read
- **操作说明:** 读取 config.json 文件
- **预期结果:** 获取配置内容
```
**然后执行:** Read工具

### 步骤3: 工具调用后输出（工具执行完成后立即输出）

```markdown
**工具返回:** [工具实际返回的结果摘要]

---
```

### 步骤4: 汇总展示（任务完成时）

在对话末尾提供简洁的执行总结：
- 共调用了多少个工具
- 主要执行步骤
- 最终结果

## 完整示例

### 示例1：基本工具调用

**用户请求：** "帮我查找当前项目中的所有JavaScript文件"

```markdown
开始执行任务。将按照一问一答格式展示所有工具调用过程。

原始请求: 帮我查找当前项目中的所有JavaScript文件

---

**问题 1:** 如何找到当前项目中所有的JavaScript文件？

**调用工具:**
- **工具来源:** 内置工具
- **工具名称:** Glob
- **操作说明:** 使用Glob工具递归搜索所有以.js结尾的文件，模式为"**/*.js"
- **预期结果:** 返回项目中所有JavaScript文件的完整路径列表

**工具返回:** 找到12个.js文件

---

## 执行总结

- 共调用 1 个工具
- 主要步骤：搜索JavaScript文件
- 结果：找到12个.js文件
```

### 示例2：多工具组合调用

**用户请求：** "读取package.json和README.md文件内容"

```markdown
开始执行任务。将按照一问一答格式展示所有工具调用过程。

原始请求: 读取package.json和README.md文件内容

---

**问题 1:** 如何获取package.json文件内容？

**调用工具:**
- **工具来源:** 内置工具
- **工具名称:** Read
- **操作说明:** 读取项目根目录下的package.json文件
- **预期结果:** 获取项目的依赖配置信息

**工具返回:** 成功读取package.json，包含项目元数据和依赖列表

---

**问题 2:** 如何获取README.md文件内容？

**调用工具:**
- **工具来源:** 内置工具
- **工具名称:** Read
- **操作说明:** 读取项目根目录下的README.md文件
- **预期结果:** 获取项目的说明文档

**工具返回:** 成功读取README.md，包含项目介绍和使用说明

---

## 执行总结

- 共调用 2 个工具
- 主要步骤：依次读取package.json和README.md
- 结果：成功获取两个文件的内容
```

## 注意事项（必须遵守）

| 序号 | 注意事项 | 说明 |
|-----|---------|------|
| 1 | **问题陈述必须明确** | 不能只有操作没有原因 |
| 2 | **工具来源必须准确** | 标明是内置工具还是具体MCP服务器 |
| 3 | **操作说明要清晰** | 描述工具的用途、参数、目标对象 |
| 4 | **预期和返回要简明** | 突出重点信息，不必全文摘录 |
| 5 | **顺序不能颠倒** | 必须先有问题，再调用工具 |
| 6 | **所有调用都要记录** | 包括内置工具、MCP工具、Skill、子代理 |
| 7 | **只在对话中展示** | 不保存文件，实时展示 |
| 8 | **绝不写入用户文件** | 工具链条不属于用户交付物 |

## 常见错误示例（避免这些做法）

### ❌ 错误1：先执行工具再输出记录

**错误的顺序：**
```
[执行Read工具] ← 先执行了！

**问题 1:** 读取配置文件  ← 后补记录，错误！

**调用工具:** ...
```

**正确顺序：**
```
**问题 1:** 如何读取配置文件？ ← 先输出问题

**调用工具:** ... ← 再输出调用信息

[执行Read工具] ← 然后执行工具

**工具返回:** ... ← 最后输出返回
```

### ❌ 错误2：缺少问题陈述

**错误：**
```
**调用工具:**
- **工具名称:** Read
- **操作说明:** 读取文件
```
（缺少**问题**部分）

**正确：**
```
**问题 1:** 如何获取配置文件内容？ ← 必须有这个问题陈述

**调用工具:** ...
```

### ❌ 错误3：将工具链条写入用户文件

**错误：**
```markdown
# 生成的报告.md

**问题 1:** 分析数据...

**调用工具:** ...

**工具返回:** ...

[报告内容] ← 工具链条不应该出现在用户文件中
```

**正确：**
```markdown
# 生成的报告.md

[只包含用户要求的报告内容，不包含任何工具链条]
```

工具链条只在对话中展示。

### ❌ 错误4：工具来源标注错误

**错误：**
```
- **工具来源:** MCP工具  ← 缺少服务器名称
```

**正确：**
```
- **工具来源:** MCP工具 (user-playwright) ← 必须注明服务器名
```

## 特殊情况处理

### 批量工具调用

当一次调用多个相似工具时，可以合并记录：

```markdown
**问题 3:** 如何获取这些配置文件的详细内容？

**调用工具:**
- **工具来源:** 内置工具
- **工具名称:** Read（批量读取）
- **操作说明:** 依次读取 config.json、settings.yaml、.env 三个配置文件
- **预期结果:** 获取所有配置文件的内容用于分析

**工具返回:** 
- config.json: 包含数据库连接配置
- settings.yaml: 包含应用运行参数
- .env: 包含环境变量定义
```

### 子代理任务

```markdown
**问题 X:** 如何执行复杂的代码分析任务？

**调用工具:**
- **工具来源:** 子代理
- **工具名称:** Task
- **操作说明:** 启动子代理执行代码复杂度分析，子代理类型为generalPurpose
- **预期结果:** 获取代码复杂度分析报告

**工具返回:** 子代理完成分析，返回包含10个高复杂度函数的详细报告
```

### MCP工具调用

```markdown
**问题 X:** 如何自动化测试网站登录功能？

**调用工具:**
- **工具来源:** MCP工具 (user-playwright)
- **工具名称:** browser_navigate
- **操作说明:** 调用Playwright浏览器自动化，导航到登录页面 https://example.com/login
- **预期结果:** 页面加载成功，准备进行登录操作

**工具返回:** 页面加载完成，检测到用户名和密码输入框
```

### Skill调用

```markdown
**问题 X:** 如何创建一个新的Agent Skill？

**调用工具:**
- **工具来源:** Skill (skill-creator)
- **工具名称:** 创建Skill
- **操作说明:** 调用skill-creator技能，创建一个新的工具链条记录器Skill
- **预期结果:** 生成完整的Skill定义文档

**工具返回:** Skill创建完成，包含名称、描述、输出格式要求和执行流程说明
```

---

## 总结

**核心口诀：先记录，后执行，再返回**

每次调用工具前，按顺序输出：
1. **问题** - 明确要解决什么问题
2. **调用工具** - 说明来源、名称、操作、预期结果
3. **执行工具** - 实际调用工具
4. **工具返回** - 记录实际返回结果

所有记录仅在对话中展示，绝不写入用户文件。
